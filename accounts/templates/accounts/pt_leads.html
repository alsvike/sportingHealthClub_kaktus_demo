{% extends 'accounts/base.html' %}

{% block title %}PT Leads{% endblock %}

{% block content %}
  <main class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">PT Leads</h1>

    <div class="p-4 bg-white border rounded shadow-sm">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
        <div>
          <p class="text-gray-700 mb-0">Her kan du oprette, redigere og slette PT leads.</p>
          <p class="text-sm text-gray-500 mt-1">Rediger: klik p√• blyant-ikonet. Slet: klik p√• skraldespand.</p>
        </div>
        <div>
          <button id="addLeadBtn" class="btn" style="background:#ff6600;color:#fff;padding:8px 12px;border-radius:8px;border:none;cursor:pointer">+ Tilf√∏j lead</button>
        </div>
      </div>

      <div style="overflow-x:auto">
        <table id="leadsTable" style="width:100%;border-collapse:collapse;min-width:900px">
          <thead style="background:#f8fafc;border-bottom:1px solid #e6eef6">
            <tr>
              <th style="text-align:left;padding:10px">Navn p√• lead</th>
              <th style="text-align:left;padding:10px">Interesse</th>
              <th style="text-align:left;padding:10px">Telefon.nr. p√• lead</th>
              <th style="text-align:left;padding:10px">Email p√• lead</th>
              <th style="text-align:left;padding:10px">Receptionist navn</th>
              <th style="text-align:left;padding:10px">ID</th>
              <th style="text-align:left;padding:10px">Tid kontaktet</th>
              <th style="text-align:center;padding:10px">Handling</th>
            </tr>
          </thead>
          <tbody id="leadsBody">
            <tr id="emptyRow"><td colspan="8" style="padding:18px;text-align:center;color:#6b7280">Ingen leads endnu. Klik p√• "Tilf√∏j lead" for at oprette en.</td></tr>
          </tbody>
        </table>
      </div>
    </div>

    <template id="lead-row-template">
      <tr>
        <td class="name"></td>
        <td class="note"></td>
        <td class="phone"></td>
        <td class="email"></td>
        <td class="receptionist"></td>
        <td class="id" style="font-family:monospace;color:#374151"></td>
        <td class="contacted_at"></td>
        <td style="text-align:center">
          <button class="edit-btn" title="Rediger" style="background:none;border:none;cursor:pointer;padding:6px">‚úèÔ∏è</button>
          <button class="delete-btn" title="Slet" style="background:none;border:none;cursor:pointer;padding:6px">üóëÔ∏è</button>
        </td>
      </tr>
    </template>

      <style>
      /* small responsive tweaks */
      #leadsTable th, #leadsTable td { border-bottom:1px solid #f1f5f9 }
  .btn:focus { outline:2px solid rgba(255,102,0,0.2) }
  input.inline-edit, textarea.inline-edit { width:100%; box-sizing:border-box; padding:6px 10px; border-radius:6px; border:1px solid #e5e7eb; }
  /* Make controls slim and single-row by default (height enforced). Textareas will grow when content increases. */
  input.inline-edit, textarea.inline-edit { height:34px; line-height:20px; }
  textarea.inline-edit { overflow:hidden; resize:none; }
  /* ensure the inline-edit controls have the same vertical offset inside table cells */
  #leadsTable td .inline-edit { display:block; margin:6px 0; }
      td.actions { text-align:center }
      /* Make note cells wrap and grow with content when not in edit mode */
      td.note{ white-space:pre-wrap; word-break:break-word; }
      /* Ensure table is responsive; allow cells to shrink on small screens */
      #leadsTable{ table-layout: auto; }
    </style>

    <script>
      (function(){
        // Simple in-memory leads store
        let leads = [];
        let nextId = 1;

        // Autosave / saved-notifier helpers (same UX as other pages)
        let lastUserInput = Date.now();
        function markUserTyped(){ lastUserInput = Date.now(); }
        const idleThreshold = 3500; // ms
        let _savedNotifyTimer = null;
        function showSavedNotification(text){
          let el = document.getElementById('saveNotifier');
          if(!el){ el = document.createElement('div'); el.id = 'saveNotifier'; el.style.position='fixed'; el.style.right='18px'; el.style.bottom='18px'; el.style.background='rgba(2,6,23,0.9)'; el.style.color='#fff'; el.style.padding='8px 12px'; el.style.borderRadius='8px'; el.style.zIndex='120'; document.body.appendChild(el); }
          el.textContent = text || '√Ündringer gemt'; el.style.opacity='1'; el.style.transform='translateY(0)';
          if(_savedNotifyTimer) clearTimeout(_savedNotifyTimer);
          _savedNotifyTimer = setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(6px)'; _savedNotifyTimer = null; }, 1800);
        }

        const _savedNotifier = { timer: null };
        function scheduleSavedNotification(){
          if(_savedNotifier.timer) clearTimeout(_savedNotifier.timer);
          _savedNotifier.timer = setTimeout(()=>{
            if(Date.now() - lastUserInput >= idleThreshold) showSavedNotification('√Ündringer gemt');
            _savedNotifier.timer = null;
          }, idleThreshold);
        }

  // debounce utility used for client-side autosave; returned fn has .cancel()
  function debounce(fn, wait){ let t; const f = function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); }; f.cancel = ()=>{ if(t) clearTimeout(t); t = null; }; return f; }

        const leadsBody = document.getElementById('leadsBody');
        const emptyRow = document.getElementById('emptyRow');
        const addBtn = document.getElementById('addLeadBtn');
        // helper to read CSRF token
        function csrftoken(){
          const name = 'csrftoken';
          const cookies = document.cookie.split(';').map(c=>c.trim());
          for(const c of cookies){ if(c.startsWith(name+'=')) return decodeURIComponent(c.split('=')[1]); }
          return '';
        }

        function formatDateTime(dt){
          if(!dt) return '';
          try{
            const d = new Date(dt);
            return d.toLocaleString();
          }catch(e){ return dt }
        }

        function render(){
          // clear existing rows except the template
          leadsBody.innerHTML = '';
          if(leads.length === 0){
            leadsBody.appendChild(emptyRow);
            return;
          }

          leads.forEach(lead => {
            const tr = document.createElement('tr');
            tr.dataset.leadId = lead._id;

            tr.innerHTML = `
              <td class="name">${escapeHtml(lead.name)}</td>
              <td class="note">${escapeHtml(lead.note)}</td>
              <td class="phone">${escapeHtml(lead.phone)}</td>
              <td class="email">${escapeHtml(lead.email)}</td>
              <td class="receptionist">${escapeHtml(lead.receptionist || '')}</td>
              <td class="id">${lead._id}</td>
              <td class="contacted_at">${formatDateTime(lead.contacted_at)}</td>
              <td style="text-align:center">
                <button class="edit-btn" title="Rediger" style="background:none;border:none;cursor:pointer;padding:6px">‚úèÔ∏è</button>
                <button class="delete-btn" title="Slet" style="background:none;border:none;cursor:pointer;padding:6px">üóëÔ∏è</button>
              </td>
            `;

            // attach events
            tr.querySelector('.edit-btn').addEventListener('click', ()=>enterEditMode(tr, lead));
            tr.querySelector('.delete-btn').addEventListener('click', ()=>deleteLead(lead._id));

            leadsBody.appendChild(tr);
          });
        }

        function escapeHtml(s){
          if(!s) return '';
          return String(s).replace(/[&<>"']/g, function(m){ return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m] });
        }

  function enterEditMode(tr, lead){
          // replace cells with inputs
          tr.innerHTML = '';
          const nameTd = document.createElement('td');
          const nameInput = document.createElement('input'); nameInput.className='inline-edit'; nameInput.value = lead.name || '';
          nameTd.appendChild(nameInput);

          const noteTd = document.createElement('td');
          const noteInput = document.createElement('textarea'); noteInput.className='inline-edit'; noteInput.rows=1; noteInput.value = lead.note || '';
          // ensure no manual resize handle (we control resize programmatically)
          noteInput.style.resize = 'none';
          noteTd.appendChild(noteInput);

          const phoneTd = document.createElement('td');
          const phoneInput = document.createElement('input'); phoneInput.className='inline-edit'; phoneInput.value = lead.phone || '';
          phoneTd.appendChild(phoneInput);

          const emailTd = document.createElement('td');
          const emailInput = document.createElement('input'); emailInput.className='inline-edit'; emailInput.value = lead.email || '';
          emailTd.appendChild(emailInput);

          const recTd = document.createElement('td');
          const recInput = document.createElement('input'); recInput.className='inline-edit'; recInput.value = lead.receptionist || '';
          recTd.appendChild(recInput);

          const idTd = document.createElement('td'); idTd.textContent = lead._id; idTd.style.fontFamily='monospace';

          const contactedTd = document.createElement('td');
          const contactedInput = document.createElement('input'); contactedInput.type='datetime-local';
          if(lead.contacted_at){
            // populate as local datetime value yyyy-MM-ddTHH:mm
            const d = new Date(lead.contacted_at);
            const pad = n=>String(n).padStart(2,'0');
            const val = d.getFullYear()+'-'+pad(d.getMonth()+1)+'-'+pad(d.getDate())+'T'+pad(d.getHours())+':'+pad(d.getMinutes());
            contactedInput.value = val;
          }
          contactedInput.className='inline-edit'; contactedTd.appendChild(contactedInput);

            const actionsTd = document.createElement('td'); actionsTd.style.textAlign='center';
            // doneBtn finishes edit mode (no explicit save required since edits autosave)
            const doneBtn = document.createElement('button'); doneBtn.textContent='‚Üê'; doneBtn.title='F√¶rdig'; doneBtn.style.background='none'; doneBtn.style.border='none'; doneBtn.style.cursor='pointer'; doneBtn.style.padding='6px';
            const cancelBtn = document.createElement('button'); cancelBtn.textContent='‚úñ'; cancelBtn.title='Annuller'; cancelBtn.style.background='none'; cancelBtn.style.border='none'; cancelBtn.style.cursor='pointer'; cancelBtn.style.padding='6px';
            actionsTd.appendChild(doneBtn); actionsTd.appendChild(cancelBtn);

          tr.appendChild(nameTd);
          tr.appendChild(noteTd);
          tr.appendChild(phoneTd);
          tr.appendChild(emailTd);
          tr.appendChild(recTd);
          tr.appendChild(idTd);
          tr.appendChild(contactedTd);
          tr.appendChild(actionsTd);

          // keep a copy of original values so cancel can restore them
          const original = { name: lead.name, note: lead.note, phone: lead.phone, email: lead.email, receptionist: lead.receptionist, contacted_at: lead.contacted_at };

          // small auto-resize helper for textareas
          function attachAutoResize(el){
            if(!el) return;
            // compute the effective minHeight from CSS (fallback to 0)
            const cs = getComputedStyle(el);
            const minH = parseFloat(cs.minHeight) || 0;
            const resize = ()=>{
              el.style.height = 'auto';
              // ensure we never shrink below CSS min-height
              const h = Math.max(el.scrollHeight, minH);
              el.style.height = (h) + 'px';
            };
            // init
            resize();
            el.addEventListener('input', resize);
            // expose for manual triggering
            return resize;
          }

          // autosave handler (client-side): update lead object and schedule saved notification
          const doLocalSave = debounce(async ()=>{
            // update local copy immediately
            lead.name = nameInput.value.trim();
            lead.note = noteInput.value.trim();
            lead.phone = phoneInput.value.trim();
            lead.email = emailInput.value.trim();
            lead.receptionist = recInput.value.trim();
            lead.contacted_at = contactedInput.value ? new Date(contactedInput.value).toISOString() : null;
            // persist to server if this lead has an integer id
            try{
              if(typeof lead._id === 'number'){
                await fetch(`/accounts/api/pt_leads/${lead._id}/`, {method:'PATCH', headers:{'Content-Type':'application/json','X-CSRFToken':csrftoken()}, credentials:'same-origin', body: JSON.stringify({name:lead.name,note:lead.note,phone:lead.phone,email:lead.email,receptionist_id:lead.receptionist_id || null,contacted_at:lead.contacted_at})});
              }
            }catch(e){ console.error('Autosave failed', e); }
            markUserTyped(); scheduleSavedNotification();
          }, 600);

          // make the note textarea auto-resize to match content and be responsive
          attachAutoResize(noteInput);
          // ensure initial height matches the single-line input height so it lines up visually
          try{
            const inputH = nameInput.getBoundingClientRect().height;
            if(noteInput.scrollHeight < inputH) noteInput.style.height = inputH + 'px';
          }catch(e){ /* ignore in old browsers */ }

          // immediate save helper (flush changes now). If this is a new unsaved lead, create it first.
          const doImmediateSave = async ()=>{
            if(doLocalSave && typeof doLocalSave.cancel === 'function') doLocalSave.cancel();
            lead.name = nameInput.value.trim();
            lead.note = noteInput.value.trim();
            lead.phone = phoneInput.value.trim();
            lead.email = emailInput.value.trim();
            lead.receptionist = recInput.value.trim();
            lead.contacted_at = contactedInput.value ? new Date(contactedInput.value).toISOString() : null;
            // if lead._id is a temporary string (starts with 'L'), create on server
            try{
              if(typeof lead._id !== 'number'){
                const res = await fetch('/accounts/api/pt_leads/', {method:'POST', headers:{'Content-Type':'application/json','X-CSRFToken':csrftoken()}, credentials:'same-origin', body: JSON.stringify({name:lead.name,note:lead.note,phone:lead.phone,email:lead.email,contacted_at:lead.contacted_at})});
                if(res.ok){ const data = await res.json(); const created = data.lead; lead._id = created.id; lead.receptionist = created.receptionist; lead.receptionist_id = created.receptionist_id; }
              } else {
                await fetch(`/accounts/api/pt_leads/${lead._id}/`, {method:'PATCH', headers:{'Content-Type':'application/json','X-CSRFToken':csrftoken()}, credentials:'same-origin', body: JSON.stringify({name:lead.name,note:lead.note,phone:lead.phone,email:lead.email,contacted_at:lead.contacted_at})});
              }
            }catch(e){ console.error('Save failed', e); }
            markUserTyped(); scheduleSavedNotification();
          };

          // wire inputs to autosave
          [nameInput, noteInput, phoneInput, emailInput, recInput, contactedInput].forEach(el=>{
            el.addEventListener('input', ()=>{ markUserTyped(); doLocalSave(); });
            // pressing Enter should finish editing (like clicking 'F√¶rdig')
            el.addEventListener('keydown', (e)=>{
              if(e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey){
                e.preventDefault();
                // simulate clicking doneBtn
                try{ doneBtn.click(); }catch(ex){ /* ignore */ }
              }
            });
          });

          // helper: render this single row back into display mode (without re-rendering whole list)
          function renderDisplayRow(trEl, leadObj){
            trEl.dataset.leadId = leadObj._id;
            trEl.innerHTML = `
              <td class="name">${escapeHtml(leadObj.name)}</td>
              <td class="note">${escapeHtml(leadObj.note)}</td>
              <td class="phone">${escapeHtml(leadObj.phone)}</td>
              <td class="email">${escapeHtml(leadObj.email)}</td>
              <td class="receptionist">${escapeHtml(leadObj.receptionist || '')}</td>
              <td class="id">${leadObj._id}</td>
              <td class="contacted_at">${formatDateTime(leadObj.contacted_at)}</td>
              <td style="text-align:center">
                <button class="edit-btn" title="Rediger" style="background:none;border:none;cursor:pointer;padding:6px">‚úèÔ∏è</button>
                <button class="delete-btn" title="Slet" style="background:none;border:none;cursor:pointer;padding:6px">üóëÔ∏è</button>
              </td>
            `;
            // attach events only for this row
            const editBtn = trEl.querySelector('.edit-btn');
            const delBtn = trEl.querySelector('.delete-btn');
            if(editBtn) editBtn.addEventListener('click', ()=>enterEditMode(trEl, leadObj));
            if(delBtn) delBtn.addEventListener('click', ()=>deleteLead(leadObj._id));
          }

          // done = flush any pending autosave and exit edit mode for only this row
          doneBtn.addEventListener('click', async ()=>{
            await doImmediateSave();
            // update the displayed row for this lead without touching other rows
            renderDisplayRow(tr, lead);
          });

          // cancel = discard any pending autosave. If there were no original values, ask to delete; otherwise restore originals for just this row.
          cancelBtn.addEventListener('click', ()=>{
            if(doLocalSave && typeof doLocalSave.cancel === 'function') doLocalSave.cancel();
            const allEmpty = !(original.name || original.note || original.phone || original.email || original.receptionist || original.contacted_at);
            if(allEmpty){
              if(confirm('Der var ingen v√¶rdier f√∏r redigering. Vil du slette denne lead i stedet for at lade den st√• tom?')){
                deleteLead(lead._id);
                return;
              } else {
                // leave empty as user chose; just render display for this row (it will show empty fields)
                renderDisplayRow(tr, lead);
                return;
              }
            }
            // otherwise restore original values for only this lead and re-render this row
            lead.name = original.name; lead.note = original.note; lead.phone = original.phone; lead.email = original.email; lead.receptionist = original.receptionist; lead.contacted_at = original.contacted_at;
            renderDisplayRow(tr, lead);
          });
        }

        async function deleteLead(id){
          if(!confirm('Er du sikker p√• at du vil slette denne lead?')) return;
          try{
            if(typeof id === 'number'){
              const res = await fetch(`/accounts/api/pt_leads/${id}/`, {method:'DELETE', headers:{'X-CSRFToken':csrftoken()}, credentials:'same-origin'});
              if(!res.ok){ const txt = await res.text(); console.error('Delete failed', res.status, txt); alert('Sletning fejlede'); return; }
            }
          }catch(e){ console.error('Delete error', e); alert('Sletning fejlede'); return; }
          leads = leads.filter(l=>l._id !== id);
          render();
        }

        addBtn.addEventListener('click', async ()=>{
          // create a new blank lead on the server then open in edit mode
          try{
            const res = await fetch('/accounts/api/pt_leads/', {method:'POST', headers:{'Content-Type':'application/json','X-CSRFToken':csrftoken()}, credentials:'same-origin', body: JSON.stringify({name:'',note:'',phone:'',email:'',contacted_at:null})});
            if(!res.ok){ const txt = await res.text(); console.error('Create failed', res.status, txt); alert('Oprettelse mislykkedes'); return; }
            const data = await res.json(); const created = data.lead;
            // normalize to our client shape
            const clientLead = { _id: created.id, name: created.name, note: created.note, phone: created.phone, email: created.email, receptionist: created.receptionist, receptionist_id: created.receptionist_id, contacted_at: created.contacted_at, created_at: created.created_at };
            // push to the end so oldest leads are on top (array order = top-down oldest->newest)
            leads.push(clientLead);
            render();
            // enter edit mode on the row we just created (find by data-lead-id)
            const createdRow = leadsBody.querySelector(`tr[data-lead-id="${created.id}"]`);
            if(createdRow){ const btn = createdRow.querySelector('.edit-btn'); if(btn) btn.click(); }
          }catch(e){ console.error('Create error', e); alert('Oprettelse mislykkedes'); }
        });

        // load existing leads from server and render (ensure oldest first)
        (async function loadLeads(){
          try{
            const res = await fetch('/accounts/api/pt_leads/', {credentials:'same-origin'});
            if(res.ok){ const data = await res.json(); leads = (data.leads || []).map(l=>({ _id: l.id, name: l.name, note: l.note, phone: l.phone, email: l.email, receptionist: l.receptionist, receptionist_id: l.receptionist_id, contacted_at: l.contacted_at, created_at: l.created_at }));
              // sort ascending by created_at (oldest first). If created_at missing, fall back to numeric id.
              leads.sort((a,b)=>{
                const ta = a.created_at ? Date.parse(a.created_at) : (typeof a._id === 'number' ? a._id : 0);
                const tb = b.created_at ? Date.parse(b.created_at) : (typeof b._id === 'number' ? b._id : 0);
                return ta - tb;
              });
            }
          }catch(e){ console.error('Failed to load leads', e); }
          render();
        })();
      })();
    </script>
  </main>
{% endblock %}
